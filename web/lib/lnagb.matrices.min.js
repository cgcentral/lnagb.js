class e{constructor(e,t,s){this.size={rows:e,columns:t},this.numberOfEntries=e*t,this.elements=s||new Array(this.numberOfEntries).fill(0)}get rows(){let e=[],t=this.elements,s=this.size,r=s.rows,i=s.columns,n=0;for(let s=0;s<r;s++,n++){let s=[];for(let e=0;e<i;e++,n++)s.push(t[n]);e.push(s),n--}return e}get columns(){let e=[],t=this.elements,s=this.size,r=s.rows+1,i=s.columns,n=i+1,l=-i;for(let s=1;s<n;s++){let s=[],n=i;for(let e=1;e<r;e++)s.push(t[n+l]),n+=i;e.push(s),l++}return e}get mainDiagonal(){let e=this.elements,t=this.size,s=t.rows,r=t.columns,i=[],n=(s<r?s:r)+1,l=-1;for(let t=1;t<n;t++)i.push(e[l+t]),l+=r;return i}clone(){let e=this.size,t=e.rows,s=e.columns;return new this.constructor(t,s,this.elements.slice())}equals(e){let t=this.size,s=t.rows,r=t.columns,i=e.size;if(s!==i.rows||r!==i.columns)return!1;let n=this.elements,l=e.elements,h=s*r;for(let e=0;e<h;e++)if(n[e]!==l[e])return!1;return!0}entry(e,t){let s=this.size;return this.elements[e*s.columns+t-s.columns-1]}row(e){let t=this.elements,s=this.size.columns,r=e*s,i=[];for(let e=r-s;e<r;e++)i.push(t[e]);return i}column(e){let t=this.elements,s=this.size,r=s.rows,i=s.columns,n=[],l=r+1,h=e-(i+1),o=i;for(let e=1;e<l;e++)n.push(t[o+h]),o+=i;return n}leadingCoefficient(e){let t=this.elements,s=this.size.columns,r=e*s;for(let e,i=r-s;i<r;i++)if(e=t[i],0!==e)return e}forEach(e,t){let s=this,r=this.elements,i=r.length,n=this.size.columns,l=e.bind(t),h=1,o=1;for(let e=0;e<i;e++){l(r[e],h,o,e,s),o++,o>n&&(o=1,h++)}}forEachRow(e,t){let s=this,r=this.elements,i=this.size,n=i.rows,l=i.columns,h=e.bind(t),o=0;for(let e=1,t=n+1;e<t;e++,o++){let t=[];for(let e=0;e<l;e++,o++)t.push(r[o]);o--,h(t,e,s)}}forEachColumn(e,t){let s=this,r=this.elements,i=this.size,n=i.rows+1,l=i.columns,h=l+1,o=e.bind(t),u=-l;for(let e=1;e<h;e++){let t=[],i=l;for(let e=1;e<n;e++)t.push(r[i+u]),i+=l;o(t,e,s),u++}}interchargeRows(e,t){let s=this.elements,r=this.size.columns,i=r+1,n=e*r+1-i,l=t*r+1-i;for(let e=1;e<i;e++)[s[n++],s[l++]]=[s[l],s[n]];return this}multiplyRowByScalar(e,t){let s=this.elements,r=this.size.columns,i=e*r;for(let e=i-r;e<i;e++)s[e]*=t;return this}addRowTimesScalarToRow(e,t,s=1){let r=this.elements,i=this.size.columns,n=t*i;for(let t=e*i-i,l=n-i;l<n;t++,l++)r[t]+=r[l]*s;return this}transpose(){let e=this.elements,t=this.size,s=t.rows,r=s*t.columns,i=r-1,n=new Array(r);n[0]=e[0],n[i]=e[i];for(let t=1;t<i;t++)n[t*s%i]=e[t];return this.elements=n,[t.rows,t.columns]=[t.columns,t.rows],this}multiplyScalar(e){let t=this.elements;for(let s=0,r=this.numberOfEntries;s<r;s++)t[s]*=e;return this}negate(){return this.multiplyScalar(-1)}add(e){let t=this.size,s=e.size;if(t.rows!==s.rows||t.columns!==s.columns)return console.error("Incompatible matrices for addition"),this;let r=this.elements,i=e.elements,n=this.numberOfEntries;for(let e=0;e<n;e++)r[e]+=i[e];return this}sub(e){let t=this.size,s=e.size;if(t.rows!==s.rows||t.columns!==s.columns)return console.error("Incompatible matrices for subtraction"),this;let r=this.elements,i=e.elements,n=this.numberOfEntries;for(let e=0;e<n;e++)r[e]-=i[e];return this}multiply(e){let t=this.size,s=t.rows,r=t.columns,i=e.size,n=i.rows,l=i.columns;if(r!==n)return console.error("Input matrix is incompatible for multiplication"),this;let h=this.elements,o=e.elements,u=[],m=s+1,c=r+1,a=l+1;for(let e=1;e<m;e++)for(let t=1;t<a;t++){let s=0;for(let i=1;i<c;i++)s+=h[e*r+i-c]*o[i*l+t-a];u.push(s)}return this.elements=u,this.size.columns=l,this.numberOfEntries=s*l,this}}class t{constructor(e=0,t=0,s=0,r=0){this.size={rows:2,columns:2},this.numberOfEntries=4,this.elements=[e,t,s,r]}get rows(){let e=this.elements;return[[e[0],e[1]],[e[2],e[3]]]}get columns(){let e=this.elements;return[[e[0],e[2]],[e[1],e[3]]]}get mainDiagonal(){let e=this.elements;return[e[0],e[3]]}clone(){return new this.constructor(...this.elements)}equals(e){let t=e.size;if(2!==t.rows||2!==t.columns)return!1;let s=this.elements,r=e.elements;return s[0]===r[0]&&s[1]===r[1]&&s[2]===r[2]&&s[3]===r[3]}entry(e,t){return this.elements[2*e+t-3]}row(e){let t=this.elements;switch(e){case 1:return[t[0],t[1]];case 2:return[t[2],t[3]];default:return}}column(e){let t=this.elements;switch(e){case 1:return[t[0],t[2]];case 2:return[t[1],t[3]];default:return}}leadingCoefficient(e){let t=this.elements;switch(e){case 1:return 0!==t[0]?t[0]:0!==t[1]?t[1]:void 0;case 2:return 0!==t[2]?t[2]:0!==t[3]?t[3]:void 0;default:return}}forEach(e,t){let s=this.elements,r=e.bind(t);r(s[0],1,1,0,this),r(s[1],1,2,1,this),r(s[2],2,1,2,this),r(s[3],2,2,3,this)}forEachRow(e,t){let s=this.elements,r=e.bind(t);r([s[0],s[1]],1,this),r([s[2],s[3]],2,this)}forEachColumn(e,t){let s=this.elements,r=e.bind(t);r([s[0],s[2]],1,this),r([s[1],s[3]],2,this)}interchargeRows(){let e=this.elements;return[e[0],e[2]]=[e[2],e[0]],[e[1],e[3]]=[e[3],e[1]],this}multiplyRowByScalar(e,t){let s=this.elements;switch(e){case 1:return s[0]*=t,s[1]*=t,this;case 2:return s[2]*=t,s[3]*=t,this;default:return this}}addRowTimesScalarToRow(e,t,s=1){let r=this.elements,i=2*e-2,n=2*t-2;return r[i]+=r[n]*s,r[i+1]+=r[n+1]*s,this}transpose(){let e=this.elements;return[e[1],e[2]]=[e[2],e[1]],this}multiplyScalar(e){let t=this.elements;return t[0]*=e,t[1]*=e,t[2]*=e,t[3]*=e,this}negate(){return this.multiplyScalar(-1)}add(e){let t=this.elements,s=e.elements;return t[0]+=s[0],t[1]+=s[1],t[2]+=s[2],t[3]+=s[3],this}sub(e){let t=this.elements,s=e.elements;return t[0]-=s[0],t[1]-=s[1],t[2]-=s[2],t[3]-=s[3],this}multiply(e){let t=this.elements,s=e.elements,r=t[0],i=t[1],n=t[2],l=t[3],h=s[0],o=s[1],u=s[2],m=s[3];return t[0]=r*h+i*u,t[1]=r*o+i*m,t[2]=n*h+l*u,t[3]=n*o+l*m,this}}class s{constructor(e=0,t=0,s=0,r=0,i=0,n=0,l=0,h=0,o=0){this.size={rows:3,columns:3},this.numberOfEntries=9,this.elements=[e,t,s,r,i,n,l,h,o]}get rows(){let e=this.elements;return[[e[0],e[1],e[2]],[e[3],e[4],e[5]],[e[6],e[7],e[8]]]}get columns(){let e=this.elements;return[[e[0],e[3],e[6]],[e[1],e[4],e[7]],[e[2],e[5],e[8]]]}get mainDiagonal(){let e=this.elements;return[e[0],e[4],e[8]]}clone(){return new this.constructor(...this.elements)}equals(e){let t=e.size;if(3!==t.rows||3!==t.columns)return!1;let s=this.elements,r=e.elements;return s[0]===r[0]&&s[1]===r[1]&&s[2]===r[2]&&s[3]===r[3]&&s[4]===r[4]&&s[5]===r[5]&&s[6]===r[6]&&s[7]===r[7]&&s[8]===r[8]}entry(e,t){return this.elements[3*e+t-4]}row(e){let t=this.elements;switch(e){case 1:return[t[0],t[1],t[2]];case 2:return[t[3],t[4],t[5]];case 3:return[t[6],t[7],t[8]];default:return}}column(e){let t=this.elements;switch(e){case 1:return[t[0],t[3],t[6]];case 2:return[t[1],t[4],t[7]];case 3:return[t[2],t[5],t[8]];default:return}}leadingCoefficient(e){let t=this.elements;switch(e){case 1:return 0!==t[0]?t[0]:0!==t[1]?t[1]:0!==t[2]?t[2]:void 0;case 2:return 0!==t[3]?t[3]:0!==t[4]?t[4]:0!==t[5]?t[5]:void 0;case 3:return 0!==t[6]?t[6]:0!==t[7]?t[7]:0!==t[8]?t[8]:void 0;default:return}}forEach(e,t){let s=this.elements,r=e.bind(t);r(s[0],1,1,0,this),r(s[1],1,2,1,this),r(s[2],1,3,2,this),r(s[3],2,1,3,this),r(s[4],2,2,4,this),r(s[5],2,3,5,this),r(s[6],3,1,6,this),r(s[7],3,2,7,this),r(s[8],3,3,8,this)}forEachRow(e,t){let s=this.elements,r=e.bind(t);r([s[0],s[1],s[2]],1,this),r([s[3],s[4],s[5]],2,this),r([s[6],s[7],s[8]],3,this)}forEachColumn(e,t){let s=this.elements,r=e.bind(t);r([s[0],s[3],s[6]],1,this),r([s[1],s[4],s[7]],2,this),r([s[2],s[5],s[8]],3,this)}interchargeRows(e,t){let s=this.elements;switch(e+t){case 3:return[s[0],s[3]]=[s[3],s[0]],[s[1],s[4]]=[s[4],s[1]],[s[2],s[5]]=[s[5],s[2]],this;case 4:return[s[0],s[6]]=[s[6],s[0]],[s[1],s[7]]=[s[7],s[1]],[s[2],s[8]]=[s[8],s[2]],this;case 5:return[s[3],s[6]]=[s[6],s[3]],[s[4],s[7]]=[s[7],s[4]],[s[5],s[8]]=[s[8],s[5]],this;default:return this}}multiplyRowByScalar(e,t){let s=this.elements;switch(e){case 1:return s[0]*=t,s[1]*=t,s[2]*=t,this;case 2:return s[3]*=t,s[4]*=t,s[5]*=t,this;case 3:return s[6]*=t,s[7]*=t,s[8]*=t,this;default:return this}}addRowTimesScalarToRow(e,t,s=1){let r=this.elements,i=3*e-3,n=3*t-3;return r[i]+=r[n]*s,r[i+1]+=r[n+1]*s,r[i+2]+=r[n+2]*s,this}transpose(){let e=this.elements;return[e[1],e[3]]=[e[3],e[1]],[e[2],e[6]]=[e[6],e[2]],[e[5],e[7]]=[e[7],e[5]],this}multiplyScalar(e){let t=this.elements;return t[0]*=e,t[1]*=e,t[2]*=e,t[3]*=e,t[4]*=e,t[5]*=e,t[6]*=e,t[7]*=e,t[8]*=e,this}negate(){return this.multiplyScalar(-1)}add(e){let t=this.elements,s=e.elements;return t[0]+=s[0],t[1]+=s[1],t[2]+=s[2],t[3]+=s[3],t[4]+=s[4],t[5]+=s[5],t[6]+=s[6],t[7]+=s[7],t[8]+=s[8],this}sub(e){let t=this.elements,s=e.elements;return t[0]-=s[0],t[1]-=s[1],t[2]-=s[2],t[3]-=s[3],t[4]-=s[4],t[5]-=s[5],t[6]-=s[6],t[7]-=s[7],t[8]-=s[8],this}multiply(e){let t=this.elements,s=e.elements,r=t[0],i=t[1],n=t[2],l=t[3],h=t[4],o=t[5],u=t[6],m=t[7],c=t[8],a=s[0],f=s[1],w=s[2],d=s[3],p=s[4],z=s[5],y=s[6],g=s[7],b=s[8];return t[0]=r*a+i*d+n*y,t[1]=r*f+i*p+n*g,t[2]=r*w+i*z+n*b,t[3]=l*a+h*d+o*y,t[4]=l*f+h*p+o*g,t[5]=l*w+h*z+o*b,t[6]=u*a+m*d+c*y,t[7]=u*f+m*p+c*g,t[8]=u*w+m*z+c*b,this}}class r{constructor(e=0,t=0,s=0,r=0,i=0,n=0,l=0,h=0,o=0,u=0,m=0,c=0,a=0,f=0,w=0,d=0){this.size={rows:4,columns:4},this.numberOfEntries=16,this.elements=[e,t,s,r,i,n,l,h,o,u,m,c,a,f,w,d]}get rows(){let e=this.elements;return[[e[0],e[1],e[2],e[3]],[e[4],e[5],e[6],e[7]],[e[8],e[9],e[10],e[11]],[e[12],e[13],e[14],e[15]]]}get columns(){let e=this.elements;return[[e[0],e[4],e[8],e[12]],[e[1],e[5],e[9],e[13]],[e[2],e[6],e[10],e[14]],[e[3],e[7],e[11],e[15]]]}get mainDiagonal(){let e=this.elements;return[e[0],e[5],e[10],e[15]]}clone(){return new this.constructor(...this.elements)}equals(e){let t=e.size;if(4!==t.rows||4!==t.columns)return!1;let s=this.elements,r=e.elements;return s[0]===r[0]&&s[1]===r[1]&&s[2]===r[2]&&s[3]===r[3]&&s[4]===r[4]&&s[5]===r[5]&&s[6]===r[6]&&s[7]===r[7]&&s[8]===r[8]&&s[9]===r[9]&&s[10]===r[10]&&s[11]===r[11]&&s[12]===r[12]&&s[13]===r[13]&&s[14]===r[14]&&s[15]===r[15]}entry(e,t){return this.elements[4*e+t-5]}row(e){let t=this.elements;switch(e){case 1:return[t[0],t[1],t[2],t[3]];case 2:return[t[4],t[5],t[6],t[7]];case 3:return[t[8],t[9],t[10],t[11]];case 4:return[t[12],t[13],t[14],t[15]]}}column(e){let t=this.elements;switch(e){case 1:return[t[0],t[4],t[8],t[12]];case 2:return[t[1],t[5],t[9],t[13]];case 3:return[t[2],t[6],t[10],t[14]];case 4:return[t[3],t[7],t[11],t[15]]}}leadingCoefficient(e){let t,s=this.elements;switch(e){case 1:t=[s[0],s[1],s[2],s[3]];break;case 2:t=[s[4],s[5],s[6],s[7]];break;case 3:t=[s[8],s[9],s[10],s[11]];break;case 4:t=[s[12],s[13],s[14],s[15]];break;default:return}return t.find((e=>0!==e))}forEach(e,t){let s=this.elements,r=e.bind(t);r(s[0],1,1,0,this),r(s[1],1,2,1,this),r(s[2],1,3,2,this),r(s[3],1,4,3,this),r(s[4],2,1,4,this),r(s[5],2,2,5,this),r(s[6],2,3,6,this),r(s[7],2,4,7,this),r(s[8],3,1,8,this),r(s[9],3,2,9,this),r(s[10],3,3,10,this),r(s[11],3,4,11,this),r(s[12],4,1,12,this),r(s[13],4,2,13,this),r(s[14],4,3,14,this),r(s[15],4,4,15,this)}forEachRow(e,t){let s=this.elements,r=e.bind(t);r([s[0],s[1],s[2],s[3]],1,this),r([s[4],s[5],s[6],s[7]],2,this),r([s[8],s[9],s[10],s[11]],3,this),r([s[12],s[13],s[14],s[15]],4,this)}forEachColumn(e,t){let s=this.elements,r=e.bind(t);r([s[0],s[4],s[8],s[12]],1,this),r([s[1],s[5],s[9],s[13]],2,this),r([s[2],s[6],s[10],s[14]],3,this),r([s[3],s[7],s[11],s[15]],4,this)}interchargeRows(e,t){let s=this.elements,r=4*e-4,i=4*t-4;for(let e=0;e<4;e++)[s[r++],s[i++]]=[s[i],s[r]];return this}multiplyRowByScalar(e,t){let s=this.elements;switch(e){case 1:return s[0]*=t,s[1]*=t,s[2]*=t,s[3]*=t,this;case 2:return s[4]*=t,s[5]*=t,s[6]*=t,s[7]*=t,this;case 3:return s[8]*=t,s[9]*=t,s[10]*=t,s[11]*=t,this;case 4:return s[12]*=t,s[13]*=t,s[14]*=t,s[15]*=t,this;default:return this}}addRowTimesScalarToRow(e,t,s=1){let r=this.elements,i=4*e-4,n=4*t-4;return r[i]+=r[n]*s,r[i+1]+=r[n+1]*s,r[i+2]+=r[n+2]*s,r[i+3]+=r[n+3]*s,this}transpose(){let e=this.elements;return[e[1],e[4]]=[e[4],e[1]],[e[2],e[8]]=[e[8],e[2]],[e[3],e[12]]=[e[12],e[3]],[e[6],e[9]]=[e[9],e[6]],[e[7],e[13]]=[e[13],e[7]],[e[11],e[14]]=[e[14],e[11]],this}multiplyScalar(e){let t=this.elements;return t[0]*=e,t[1]*=e,t[2]*=e,t[3]*=e,t[4]*=e,t[5]*=e,t[6]*=e,t[7]*=e,t[8]*=e,t[9]*=e,t[10]*=e,t[11]*=e,t[12]*=e,t[13]*=e,t[14]*=e,t[15]*=e,this}negate(){return this.multiplyScalar(-1)}add(e){let t=this.elements,s=e.elements;return t[0]+=s[0],t[1]+=s[1],t[2]+=s[2],t[3]+=s[3],t[4]+=s[4],t[5]+=s[5],t[6]+=s[6],t[7]+=s[7],t[8]+=s[8],t[9]+=s[9],t[10]+=s[10],t[11]+=s[11],t[12]+=s[12],t[13]+=s[13],t[14]+=s[14],t[15]+=s[15],this}sub(e){let t=this.elements,s=e.elements;return t[0]-=s[0],t[1]-=s[1],t[2]-=s[2],t[3]-=s[3],t[4]-=s[4],t[5]-=s[5],t[6]-=s[6],t[7]-=s[7],t[8]-=s[8],t[9]-=s[9],t[10]-=s[10],t[11]-=s[11],t[12]-=s[12],t[13]-=s[13],t[14]-=s[14],t[15]-=s[15],this}multiply(e){let t=this.elements,s=e.elements,r=t[0],i=t[1],n=t[2],l=t[3],h=t[4],o=t[5],u=t[6],m=t[7],c=t[8],a=t[9],f=t[10],w=t[11],d=t[12],p=t[13],z=t[14],y=t[15],g=s[0],b=s[1],E=s[2],R=s[3],S=s[4],_=s[5],C=s[6],O=s[7],v=s[8],A=s[9],T=s[10],D=s[11],x=s[12],k=s[13],q=s[14],B=s[15];return t[0]=r*g+i*S+n*v+l*x,t[1]=r*b+i*_+n*A+l*k,t[2]=r*E+i*C+n*T+l*q,t[3]=r*R+i*O+n*D+l*B,t[4]=h*g+o*S+u*v+m*x,t[5]=h*b+o*_+u*A+m*k,t[6]=h*E+o*C+u*T+m*q,t[7]=h*R+o*O+u*D+m*B,t[8]=c*g+a*S+f*v+w*x,t[9]=c*b+a*_+f*A+w*k,t[10]=c*E+a*C+f*T+w*q,t[11]=c*R+a*O+f*D+w*B,t[12]=d*g+p*S+z*v+y*x,t[13]=d*b+p*_+z*A+y*k,t[14]=d*E+p*C+z*T+y*q,t[15]=d*R+p*O+z*D+y*B,this}}class i extends e{constructor(e,t){super(e,e,t)}identity(){let e=this.size.rows,t=e+1;this.elements=new Array(e*e).fill(0);for(let s=0;s<e;s++)this.elements[t*s]=1;return this}}class n{constructor(e){this.size={rows:e,columns:e},this.numberOfEntries=e*e,this.elements=new Array(this.numberOfEntries).fill(0);for(let t=0,s=e+1,r=this.numberOfEntries;t<r;t+=s)this.elements[t]=1;this.rank=e,this.rows=[];for(let t=0;t<e;t++){let s=new Array(e).fill(0);s[t]=1,this.rows.push(s)}this.columns=this.rows.slice(),this.mainDiagonal=new Array(e).fill(1)}clone(){return new this.constructor(this.size.rows)}equals(e){let t=this.size.rows,s=e.size;if(t!==s.rows||t!==s.columns)return!1;let r=this.elements,i=e.elements,n=t*t;for(let e=0;e<n;e++)if(r[e]!==i[e])return!1;return!0}entry(e,t){return e===t?1:0}row(e){let t=this.size.rows,s=new Array(t).fill(0);return s[e-1]=1,s}column(e){return this.row(e)}leadingCoefficient(e){return 1}forEach(e,t){let s=this,r=this.size.columns,i=r*r,n=e.bind(t),l=1,h=1;for(let e=0;e<i;e++){n(l===h?1:0,l,h,e,s),h++,h>r&&(h=1,l++)}}forEachRow(e,t){let s=this,r=this.size.rows,i=e.bind(t);for(let e=0;e<r;e++){let t=e+1,n=new Array(r).fill(0);n[e]=1,i(n,t,s)}}forEachColumn(e,t){this.forEachRow(e,t)}}class l extends e{constructor(e,t){let s=e.size,r=t.size,i=s.rows,n=s.columns,l=r.columns,h=[];for(let s=1,r=i+1;s<r;s++)h.push(...e.row(s),...t.row(s));super(i,n+l,h),this.size.left=n,this.size.right=l}get leftMatrix(){let t=this.size,s=t.rows,r=t.left,i=[];for(let e=1;e<=s;e++)for(let t=1;t<=r;t++)i.push(this.entry(e,t));return new e(s,r,i)}get rightMatrix(){let t=this.size,s=t.rows,r=t.left,i=t.right,n=[];for(let e=1;e<=s;e++)for(let t=1;t<=i;t++)n.push(this.entry(e,r+t));return new e(s,i,n)}}l.prototype.transpose=void 0,l.prototype.add=void 0,l.prototype.sub=void 0,l.prototype.multiply=void 0;class h{constructor(e){this._=e}get size(){let e=this._.size;return{rows:e.columns,columns:e.rows}}get rows(){return this._.columns}get columns(){return this._.rows}get mainDiagonal(){return this._.mainDiagonal}computeElements(){let e=this._.elements,t=this._.size,s=t.rows,r=s*t.columns,i=r-1,n=new Array(r);n[0]=e[0],n[i]=e[i];for(let t=1;t<i;t++)n[t*s%i]=e[t];return this.elements=n,n}entry(e,t){return this._.entry(t,e)}row(e){return this._.column(e)}column(e){return this._.row(e)}forEach(e,t){let s=this,r=s._,i=r.elements,n=r.size,l=n.rows,h=n.columns,o=l*h-1,u=this.size.columns,m=e.bind(t);m(i[0],1,1,0,s,r);let c=1,a=2;for(let e=1;e<o;e++){m(i[e*h%o],c,a,e,s,r),a++,a>u&&(a=1,c++)}m(i[o],h,l,o,s,r)}forEachComputed(e,t){let s=this,r=this._,i=this.elements,n=i.length,l=this.size.columns,h=1,o=1,u=e.bind(t);for(let e=0;e<n;e++){u(i[e],h,o,e,s,r),o++,o>l&&(o=1,h++)}}forEachRow(e,t){this._.forEachColumn(e,t)}forEachColumn(e,t){this._.forEachRow(e,t)}}export{l as AugmentedMatrix,n as IdentityMatrix,e as Matrix,t as Matrix2,s as Matrix3,r as Matrix4,h as MatrixTranspose,i as SquareMatrix};
