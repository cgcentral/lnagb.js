!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).lnagb={})}(this,(function(t){"use strict";class e{constructor(t,e,s){this.size={rows:t,columns:e},this.numberOfEntries=t*e,this.elements=s||new Array(this.numberOfEntries).fill(0)}get rows(){let t=[],e=this.elements,s=this.size,i=s.rows,r=s.columns,n=0;for(let s=0;s<i;s++,n++){let s=[];for(let t=0;t<r;t++,n++)s.push(e[n]);t.push(s),n--}return t}get columns(){let t=[],e=this.elements,s=this.size,i=s.rows+1,r=s.columns,n=r+1,l=-r;for(let s=1;s<n;s++){let s=[],n=r;for(let t=1;t<i;t++)s.push(e[n+l]),n+=r;t.push(s),l++}return t}get mainDiagonal(){let t=this.elements,e=this.size,s=e.rows,i=e.columns,r=[],n=(s<i?s:i)+1,l=-1;for(let e=1;e<n;e++)r.push(t[l+e]),l+=i;return r}clone(){let t=this.size,e=t.rows,s=t.columns;return new this.constructor(e,s,this.elements.slice())}equals(t){let e=this.size,s=e.rows,i=e.columns,r=t.size;if(s!==r.rows||i!==r.columns)return!1;let n=this.elements,l=t.elements,h=s*i;for(let t=0;t<h;t++)if(n[t]!==l[t])return!1;return!0}entry(t,e){let s=this.size;return this.elements[t*s.columns+e-s.columns-1]}row(t){let e=this.elements,s=this.size.columns,i=t*s,r=[];for(let t=i-s;t<i;t++)r.push(e[t]);return r}column(t){let e=this.elements,s=this.size,i=s.rows,r=s.columns,n=[],l=i+1,h=t-(r+1),o=r;for(let t=1;t<l;t++)n.push(e[o+h]),o+=r;return n}leadingCoefficient(t){let e=this.elements,s=this.size.columns,i=t*s;for(let t,r=i-s;r<i;r++)if(t=e[r],0!==t)return t}forEach(t,e){let s=this,i=this.elements,r=i.length,n=this.size.columns,l=t.bind(e),h=1,o=1;for(let t=0;t<r;t++){l(i[t],h,o,t,s),o++,o>n&&(o=1,h++)}}forEachRow(t,e){let s=this,i=this.elements,r=this.size,n=r.rows,l=r.columns,h=t.bind(e),o=0;for(let t=1,e=n+1;t<e;t++,o++){let e=[];for(let t=0;t<l;t++,o++)e.push(i[o]);o--,h(e,t,s)}}forEachColumn(t,e){let s=this,i=this.elements,r=this.size,n=r.rows+1,l=r.columns,h=l+1,o=t.bind(e),u=-l;for(let t=1;t<h;t++){let e=[],r=l;for(let t=1;t<n;t++)e.push(i[r+u]),r+=l;o(e,t,s),u++}}interchargeRows(t,e){let s=this.elements,i=this.size.columns,r=i+1,n=t*i+1-r,l=e*i+1-r;for(let t=1;t<r;t++)[s[n++],s[l++]]=[s[l],s[n]];return this}multiplyRowByScalar(t,e){let s=this.elements,i=this.size.columns,r=t*i;for(let t=r-i;t<r;t++)s[t]*=e;return this}addRowTimesScalarToRow(t,e,s=1){let i=this.elements,r=this.size.columns,n=e*r;for(let e=t*r-r,l=n-r;l<n;e++,l++)i[e]+=i[l]*s;return this}transpose(){let t=this.elements,e=this.size,s=e.rows,i=s*e.columns,r=i-1,n=new Array(i);n[0]=t[0],n[r]=t[r];for(let e=1;e<r;e++)n[e*s%r]=t[e];return this.elements=n,[e.rows,e.columns]=[e.columns,e.rows],this}multiplyScalar(t){let e=this.elements;for(let s=0,i=this.numberOfEntries;s<i;s++)e[s]*=t;return this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.size,s=t.size;if(e.rows!==s.rows||e.columns!==s.columns)return console.error("Incompatible matrices for addition"),this;let i=this.elements,r=t.elements,n=this.numberOfEntries;for(let t=0;t<n;t++)i[t]+=r[t];return this}sub(t){let e=this.size,s=t.size;if(e.rows!==s.rows||e.columns!==s.columns)return console.error("Incompatible matrices for subtraction"),this;let i=this.elements,r=t.elements,n=this.numberOfEntries;for(let t=0;t<n;t++)i[t]-=r[t];return this}multiply(t){let e=this.size,s=e.rows,i=e.columns,r=t.size,n=r.rows,l=r.columns;if(i!==n)return console.error("Input matrix is incompatible for multiplication"),this;let h=this.elements,o=t.elements,u=[],c=s+1,a=i+1,m=l+1;for(let t=1;t<c;t++)for(let e=1;e<m;e++){let s=0;for(let r=1;r<a;r++)s+=h[t*i+r-a]*o[r*l+e-m];u.push(s)}return this.elements=u,this.size.columns=l,this.numberOfEntries=s*l,this}}class s extends e{constructor(t,e){let s=t.size,i=e.size,r=s.rows,n=s.columns,l=i.columns,h=[];for(let s=1,i=r+1;s<i;s++)h.push(...t.row(s),...e.row(s));super(r,n+l,h),this.size.left=n,this.size.right=l}get leftMatrix(){let t=this.size,s=t.rows,i=t.left,r=[];for(let t=1;t<=s;t++)for(let e=1;e<=i;e++)r.push(this.entry(t,e));return new e(s,i,r)}get rightMatrix(){let t=this.size,s=t.rows,i=t.left,r=t.right,n=[];for(let t=1;t<=s;t++)for(let e=1;e<=r;e++)n.push(this.entry(t,i+e));return new e(s,r,n)}}s.prototype.transpose=void 0,s.prototype.add=void 0,s.prototype.sub=void 0,s.prototype.multiply=void 0;t.AugmentedMatrix=s,t.IdentityMatrix=class{constructor(t){this.size={rows:t,columns:t},this.numberOfEntries=t*t,this.elements=new Array(this.numberOfEntries).fill(0);for(let e=0,s=t+1,i=this.numberOfEntries;e<i;e+=s)this.elements[e]=1;this.rank=t,this.rows=[];for(let e=0;e<t;e++){let s=new Array(t).fill(0);s[e]=1,this.rows.push(s)}this.columns=this.rows.slice(),this.mainDiagonal=new Array(t).fill(1)}clone(){return new this.constructor(this.size.rows)}equals(t){let e=this.size.rows,s=t.size;if(e!==s.rows||e!==s.columns)return!1;let i=this.elements,r=t.elements,n=e*e;for(let t=0;t<n;t++)if(i[t]!==r[t])return!1;return!0}entry(t,e){return t===e?1:0}row(t){let e=this.size.rows,s=new Array(e).fill(0);return s[t-1]=1,s}column(t){return this.row(t)}leadingCoefficient(t){return 1}forEach(t,e){let s=this,i=this.size.columns,r=i*i,n=t.bind(e),l=1,h=1;for(let t=0;t<r;t++){n(l===h?1:0,l,h,t,s),h++,h>i&&(h=1,l++)}}forEachRow(t,e){let s=this,i=this.size.rows,r=t.bind(e);for(let t=0;t<i;t++){let e=t+1,n=new Array(i).fill(0);n[t]=1,r(n,e,s)}}forEachColumn(t,e){this.forEachRow(t,e)}},t.LinearEquation=class{constructor(t,e){this.coefficients=t,this.constant=e,this.numberOfVariables=t.length}clone(){return new this.constructor(this.coefficients,this.constant)}multiplyScalar(t){let e=this.coefficients;for(let s=0,i=this.numberOfVariables;s<i;s++)e[s]*=t;return this.constant*=t,this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.numberOfVariables;if(e!==t.numberOfVariables)return console.error("Incompatible equations for addition"),this;let s=this.coefficients,i=t.coefficients;for(let t=0;t<e;t++)s[t]+=i[t];return this.constant+=t.constant,this}subtract(t){let e=this.numberOfVariables;if(t.numberOfVariables!==e)return console.error("Incompatible equations for subtraction"),this;let s=this.coefficients,i=t.coefficients;for(let t=0;t<e;t++)s[t]-=i[t];return this.constant-=t.constant,this}toArray(){return[...this.coefficients,this.constant]}},t.LinearEquation2=class{constructor(t,e,s){this.a=t,this.b=e,this.c=s,this.coefficients=[t,e],this.constant=s,this.numberOfVariables=2}clone(){return new this.constructor(this.a,this.b,this.c)}multiplyScalar(t){let e=this.coefficients;return this.a=e[0]*=t,this.b=e[1]*=t,this.c=this.constant*=t,this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.coefficients,s=t.coefficients;return this.a=e[0]+=s[0],this.b=e[1]+=s[1],this.c=this.constant+=t.constant,this}subtract(t){let e=this.coefficients,s=t.coefficients;return this.a=e[0]-=s[0],this.b=e[1]-=s[1],this.c=this.constant-=t.constant,this}},t.LinearEquation3=class{constructor(t,e,s,i){this.a=t,this.b=e,this.c=s,this.d=i,this.coefficients=[t,e,s],this.constant=i,this.numberOfVariables=3}clone(){return new this.constructor(this.a,this.b,this.c,this.d)}multiplyScalar(t){let e=this.coefficients;return this.a=e[0]*=t,this.b=e[1]*=t,this.c=e[2]*=t,this.d=this.constant*=t,this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.coefficients,s=t.coefficients;return this.a=e[0]+=s[0],this.b=e[1]+=s[1],this.c=e[2]+=s[2],this.d=this.constant+=t.constant,this}subtract(t){let e=this.coefficients,s=t.coefficients;return this.a=e[0]-=s[0],this.b=e[1]-=s[1],this.c=e[2]-=s[2],this.d=this.constant-=t.constant,this}},t.Matrix=e,t.Matrix2=class{constructor(t=0,e=0,s=0,i=0){this.size={rows:2,columns:2},this.numberOfEntries=4,this.elements=[t,e,s,i]}get rows(){let t=this.elements;return[[t[0],t[1]],[t[2],t[3]]]}get columns(){let t=this.elements;return[[t[0],t[2]],[t[1],t[3]]]}get mainDiagonal(){let t=this.elements;return[t[0],t[3]]}clone(){return new this.constructor(...this.elements)}equals(t){let e=t.size;if(2!==e.rows||2!==e.columns)return!1;let s=this.elements,i=t.elements;return s[0]===i[0]&&s[1]===i[1]&&s[2]===i[2]&&s[3]===i[3]}entry(t,e){return this.elements[2*t+e-3]}row(t){let e=this.elements;switch(t){case 1:return[e[0],e[1]];case 2:return[e[2],e[3]];default:return}}column(t){let e=this.elements;switch(t){case 1:return[e[0],e[2]];case 2:return[e[1],e[3]];default:return}}leadingCoefficient(t){let e=this.elements;switch(t){case 1:return 0!==e[0]?e[0]:0!==e[1]?e[1]:void 0;case 2:return 0!==e[2]?e[2]:0!==e[3]?e[3]:void 0;default:return}}forEach(t,e){let s=this.elements,i=t.bind(e);i(s[0],1,1,0,this),i(s[1],1,2,1,this),i(s[2],2,1,2,this),i(s[3],2,2,3,this)}forEachRow(t,e){let s=this.elements,i=t.bind(e);i([s[0],s[1]],1,this),i([s[2],s[3]],2,this)}forEachColumn(t,e){let s=this.elements,i=t.bind(e);i([s[0],s[2]],1,this),i([s[1],s[3]],2,this)}interchargeRows(){let t=this.elements;return[t[0],t[2]]=[t[2],t[0]],[t[1],t[3]]=[t[3],t[1]],this}multiplyRowByScalar(t,e){let s=this.elements;switch(t){case 1:return s[0]*=e,s[1]*=e,this;case 2:return s[2]*=e,s[3]*=e,this;default:return this}}addRowTimesScalarToRow(t,e,s=1){let i=this.elements,r=2*t-2,n=2*e-2;return i[r]+=i[n]*s,i[r+1]+=i[n+1]*s,this}transpose(){let t=this.elements;return[t[1],t[2]]=[t[2],t[1]],this}multiplyScalar(t){let e=this.elements;return e[0]*=t,e[1]*=t,e[2]*=t,e[3]*=t,this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.elements,s=t.elements;return e[0]+=s[0],e[1]+=s[1],e[2]+=s[2],e[3]+=s[3],this}sub(t){let e=this.elements,s=t.elements;return e[0]-=s[0],e[1]-=s[1],e[2]-=s[2],e[3]-=s[3],this}multiply(t){let e=this.elements,s=t.elements,i=e[0],r=e[1],n=e[2],l=e[3],h=s[0],o=s[1],u=s[2],c=s[3];return e[0]=i*h+r*u,e[1]=i*o+r*c,e[2]=n*h+l*u,e[3]=n*o+l*c,this}},t.Matrix3=class{constructor(t=0,e=0,s=0,i=0,r=0,n=0,l=0,h=0,o=0){this.size={rows:3,columns:3},this.numberOfEntries=9,this.elements=[t,e,s,i,r,n,l,h,o]}get rows(){let t=this.elements;return[[t[0],t[1],t[2]],[t[3],t[4],t[5]],[t[6],t[7],t[8]]]}get columns(){let t=this.elements;return[[t[0],t[3],t[6]],[t[1],t[4],t[7]],[t[2],t[5],t[8]]]}get mainDiagonal(){let t=this.elements;return[t[0],t[4],t[8]]}clone(){return new this.constructor(...this.elements)}equals(t){let e=t.size;if(3!==e.rows||3!==e.columns)return!1;let s=this.elements,i=t.elements;return s[0]===i[0]&&s[1]===i[1]&&s[2]===i[2]&&s[3]===i[3]&&s[4]===i[4]&&s[5]===i[5]&&s[6]===i[6]&&s[7]===i[7]&&s[8]===i[8]}entry(t,e){return this.elements[3*t+e-4]}row(t){let e=this.elements;switch(t){case 1:return[e[0],e[1],e[2]];case 2:return[e[3],e[4],e[5]];case 3:return[e[6],e[7],e[8]];default:return}}column(t){let e=this.elements;switch(t){case 1:return[e[0],e[3],e[6]];case 2:return[e[1],e[4],e[7]];case 3:return[e[2],e[5],e[8]];default:return}}leadingCoefficient(t){let e=this.elements;switch(t){case 1:return 0!==e[0]?e[0]:0!==e[1]?e[1]:0!==e[2]?e[2]:void 0;case 2:return 0!==e[3]?e[3]:0!==e[4]?e[4]:0!==e[5]?e[5]:void 0;case 3:return 0!==e[6]?e[6]:0!==e[7]?e[7]:0!==e[8]?e[8]:void 0;default:return}}forEach(t,e){let s=this.elements,i=t.bind(e);i(s[0],1,1,0,this),i(s[1],1,2,1,this),i(s[2],1,3,2,this),i(s[3],2,1,3,this),i(s[4],2,2,4,this),i(s[5],2,3,5,this),i(s[6],3,1,6,this),i(s[7],3,2,7,this),i(s[8],3,3,8,this)}forEachRow(t,e){let s=this.elements,i=t.bind(e);i([s[0],s[1],s[2]],1,this),i([s[3],s[4],s[5]],2,this),i([s[6],s[7],s[8]],3,this)}forEachColumn(t,e){let s=this.elements,i=t.bind(e);i([s[0],s[3],s[6]],1,this),i([s[1],s[4],s[7]],2,this),i([s[2],s[5],s[8]],3,this)}interchargeRows(t,e){let s=this.elements;switch(t+e){case 3:return[s[0],s[3]]=[s[3],s[0]],[s[1],s[4]]=[s[4],s[1]],[s[2],s[5]]=[s[5],s[2]],this;case 4:return[s[0],s[6]]=[s[6],s[0]],[s[1],s[7]]=[s[7],s[1]],[s[2],s[8]]=[s[8],s[2]],this;case 5:return[s[3],s[6]]=[s[6],s[3]],[s[4],s[7]]=[s[7],s[4]],[s[5],s[8]]=[s[8],s[5]],this;default:return this}}multiplyRowByScalar(t,e){let s=this.elements;switch(t){case 1:return s[0]*=e,s[1]*=e,s[2]*=e,this;case 2:return s[3]*=e,s[4]*=e,s[5]*=e,this;case 3:return s[6]*=e,s[7]*=e,s[8]*=e,this;default:return this}}addRowTimesScalarToRow(t,e,s=1){let i=this.elements,r=3*t-3,n=3*e-3;return i[r]+=i[n]*s,i[r+1]+=i[n+1]*s,i[r+2]+=i[n+2]*s,this}transpose(){let t=this.elements;return[t[1],t[3]]=[t[3],t[1]],[t[2],t[6]]=[t[6],t[2]],[t[5],t[7]]=[t[7],t[5]],this}multiplyScalar(t){let e=this.elements;return e[0]*=t,e[1]*=t,e[2]*=t,e[3]*=t,e[4]*=t,e[5]*=t,e[6]*=t,e[7]*=t,e[8]*=t,this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.elements,s=t.elements;return e[0]+=s[0],e[1]+=s[1],e[2]+=s[2],e[3]+=s[3],e[4]+=s[4],e[5]+=s[5],e[6]+=s[6],e[7]+=s[7],e[8]+=s[8],this}sub(t){let e=this.elements,s=t.elements;return e[0]-=s[0],e[1]-=s[1],e[2]-=s[2],e[3]-=s[3],e[4]-=s[4],e[5]-=s[5],e[6]-=s[6],e[7]-=s[7],e[8]-=s[8],this}multiply(t){let e=this.elements,s=t.elements,i=e[0],r=e[1],n=e[2],l=e[3],h=e[4],o=e[5],u=e[6],c=e[7],a=e[8],m=s[0],f=s[1],w=s[2],b=s[3],d=s[4],p=s[5],y=s[6],z=s[7],E=s[8];return e[0]=i*m+r*b+n*y,e[1]=i*f+r*d+n*z,e[2]=i*w+r*p+n*E,e[3]=l*m+h*b+o*y,e[4]=l*f+h*d+o*z,e[5]=l*w+h*p+o*E,e[6]=u*m+c*b+a*y,e[7]=u*f+c*d+a*z,e[8]=u*w+c*p+a*E,this}},t.Matrix4=class{constructor(t=0,e=0,s=0,i=0,r=0,n=0,l=0,h=0,o=0,u=0,c=0,a=0,m=0,f=0,w=0,b=0){this.size={rows:4,columns:4},this.numberOfEntries=16,this.elements=[t,e,s,i,r,n,l,h,o,u,c,a,m,f,w,b]}get rows(){let t=this.elements;return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}get columns(){let t=this.elements;return[[t[0],t[4],t[8],t[12]],[t[1],t[5],t[9],t[13]],[t[2],t[6],t[10],t[14]],[t[3],t[7],t[11],t[15]]]}get mainDiagonal(){let t=this.elements;return[t[0],t[5],t[10],t[15]]}clone(){return new this.constructor(...this.elements)}equals(t){let e=t.size;if(4!==e.rows||4!==e.columns)return!1;let s=this.elements,i=t.elements;return s[0]===i[0]&&s[1]===i[1]&&s[2]===i[2]&&s[3]===i[3]&&s[4]===i[4]&&s[5]===i[5]&&s[6]===i[6]&&s[7]===i[7]&&s[8]===i[8]&&s[9]===i[9]&&s[10]===i[10]&&s[11]===i[11]&&s[12]===i[12]&&s[13]===i[13]&&s[14]===i[14]&&s[15]===i[15]}entry(t,e){return this.elements[4*t+e-5]}row(t){let e=this.elements;switch(t){case 1:return[e[0],e[1],e[2],e[3]];case 2:return[e[4],e[5],e[6],e[7]];case 3:return[e[8],e[9],e[10],e[11]];case 4:return[e[12],e[13],e[14],e[15]]}}column(t){let e=this.elements;switch(t){case 1:return[e[0],e[4],e[8],e[12]];case 2:return[e[1],e[5],e[9],e[13]];case 3:return[e[2],e[6],e[10],e[14]];case 4:return[e[3],e[7],e[11],e[15]]}}leadingCoefficient(t){let e,s=this.elements;switch(t){case 1:e=[s[0],s[1],s[2],s[3]];break;case 2:e=[s[4],s[5],s[6],s[7]];break;case 3:e=[s[8],s[9],s[10],s[11]];break;case 4:e=[s[12],s[13],s[14],s[15]];break;default:return}return e.find((t=>0!==t))}forEach(t,e){let s=this.elements,i=t.bind(e);i(s[0],1,1,0,this),i(s[1],1,2,1,this),i(s[2],1,3,2,this),i(s[3],1,4,3,this),i(s[4],2,1,4,this),i(s[5],2,2,5,this),i(s[6],2,3,6,this),i(s[7],2,4,7,this),i(s[8],3,1,8,this),i(s[9],3,2,9,this),i(s[10],3,3,10,this),i(s[11],3,4,11,this),i(s[12],4,1,12,this),i(s[13],4,2,13,this),i(s[14],4,3,14,this),i(s[15],4,4,15,this)}forEachRow(t,e){let s=this.elements,i=t.bind(e);i([s[0],s[1],s[2],s[3]],1,this),i([s[4],s[5],s[6],s[7]],2,this),i([s[8],s[9],s[10],s[11]],3,this),i([s[12],s[13],s[14],s[15]],4,this)}forEachColumn(t,e){let s=this.elements,i=t.bind(e);i([s[0],s[4],s[8],s[12]],1,this),i([s[1],s[5],s[9],s[13]],2,this),i([s[2],s[6],s[10],s[14]],3,this),i([s[3],s[7],s[11],s[15]],4,this)}interchargeRows(t,e){let s=this.elements,i=4*t-4,r=4*e-4;for(let t=0;t<4;t++)[s[i++],s[r++]]=[s[r],s[i]];return this}multiplyRowByScalar(t,e){let s=this.elements;switch(t){case 1:return s[0]*=e,s[1]*=e,s[2]*=e,s[3]*=e,this;case 2:return s[4]*=e,s[5]*=e,s[6]*=e,s[7]*=e,this;case 3:return s[8]*=e,s[9]*=e,s[10]*=e,s[11]*=e,this;case 4:return s[12]*=e,s[13]*=e,s[14]*=e,s[15]*=e,this;default:return this}}addRowTimesScalarToRow(t,e,s=1){let i=this.elements,r=4*t-4,n=4*e-4;return i[r]+=i[n]*s,i[r+1]+=i[n+1]*s,i[r+2]+=i[n+2]*s,i[r+3]+=i[n+3]*s,this}transpose(){let t=this.elements;return[t[1],t[4]]=[t[4],t[1]],[t[2],t[8]]=[t[8],t[2]],[t[3],t[12]]=[t[12],t[3]],[t[6],t[9]]=[t[9],t[6]],[t[7],t[13]]=[t[13],t[7]],[t[11],t[14]]=[t[14],t[11]],this}multiplyScalar(t){let e=this.elements;return e[0]*=t,e[1]*=t,e[2]*=t,e[3]*=t,e[4]*=t,e[5]*=t,e[6]*=t,e[7]*=t,e[8]*=t,e[9]*=t,e[10]*=t,e[11]*=t,e[12]*=t,e[13]*=t,e[14]*=t,e[15]*=t,this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.elements,s=t.elements;return e[0]+=s[0],e[1]+=s[1],e[2]+=s[2],e[3]+=s[3],e[4]+=s[4],e[5]+=s[5],e[6]+=s[6],e[7]+=s[7],e[8]+=s[8],e[9]+=s[9],e[10]+=s[10],e[11]+=s[11],e[12]+=s[12],e[13]+=s[13],e[14]+=s[14],e[15]+=s[15],this}sub(t){let e=this.elements,s=t.elements;return e[0]-=s[0],e[1]-=s[1],e[2]-=s[2],e[3]-=s[3],e[4]-=s[4],e[5]-=s[5],e[6]-=s[6],e[7]-=s[7],e[8]-=s[8],e[9]-=s[9],e[10]-=s[10],e[11]-=s[11],e[12]-=s[12],e[13]-=s[13],e[14]-=s[14],e[15]-=s[15],this}multiply(t){let e=this.elements,s=t.elements,i=e[0],r=e[1],n=e[2],l=e[3],h=e[4],o=e[5],u=e[6],c=e[7],a=e[8],m=e[9],f=e[10],w=e[11],b=e[12],d=e[13],p=e[14],y=e[15],z=s[0],E=s[1],g=s[2],O=s[3],x=s[4],S=s[5],q=s[6],R=s[7],M=s[8],C=s[9],V=s[10],_=s[11],v=s[12],A=s[13],T=s[14],I=s[15];return e[0]=i*z+r*x+n*M+l*v,e[1]=i*E+r*S+n*C+l*A,e[2]=i*g+r*q+n*V+l*T,e[3]=i*O+r*R+n*_+l*I,e[4]=h*z+o*x+u*M+c*v,e[5]=h*E+o*S+u*C+c*A,e[6]=h*g+o*q+u*V+c*T,e[7]=h*O+o*R+u*_+c*I,e[8]=a*z+m*x+f*M+w*v,e[9]=a*E+m*S+f*C+w*A,e[10]=a*g+m*q+f*V+w*T,e[11]=a*O+m*R+f*_+w*I,e[12]=b*z+d*x+p*M+y*v,e[13]=b*E+d*S+p*C+y*A,e[14]=b*g+d*q+p*V+y*T,e[15]=b*O+d*R+p*_+y*I,this}},t.MatrixTranspose=class{constructor(t){this._=t}get size(){let t=this._.size;return{rows:t.columns,columns:t.rows}}get rows(){return this._.columns}get columns(){return this._.rows}get mainDiagonal(){return this._.mainDiagonal}computeElements(){let t=this._.elements,e=this._.size,s=e.rows,i=s*e.columns,r=i-1,n=new Array(i);n[0]=t[0],n[r]=t[r];for(let e=1;e<r;e++)n[e*s%r]=t[e];return this.elements=n,n}entry(t,e){return this._.entry(e,t)}row(t){return this._.column(t)}column(t){return this._.row(t)}forEach(t,e){let s=this,i=s._,r=i.elements,n=i.size,l=n.rows,h=n.columns,o=l*h-1,u=this.size.columns,c=t.bind(e);c(r[0],1,1,0,s,i);let a=1,m=2;for(let t=1;t<o;t++){c(r[t*h%o],a,m,t,s,i),m++,m>u&&(m=1,a++)}c(r[o],h,l,o,s,i)}forEachComputed(t,e){let s=this,i=this._,r=this.elements,n=r.length,l=this.size.columns,h=1,o=1,u=t.bind(e);for(let t=0;t<n;t++){u(r[t],h,o,t,s,i),o++,o>l&&(o=1,h++)}}forEachRow(t,e){this._.forEachColumn(t,e)}forEachColumn(t,e){this._.forEachRow(t,e)}},t.SquareMatrix=class extends e{constructor(t,e){super(t,t,e)}identity(){let t=this.size.rows,e=t+1;this.elements=new Array(t*t).fill(0);for(let s=0;s<t;s++)this.elements[e*s]=1;return this}},t.SystemOfLinearEquations=class{constructor(t){this.equations=t,this.numberOfVariables=t[0].numberOfVariables,this.numberOfEquations=t.legnth}clone(){return new this.constructor(this.equations.slice())}computeCoefficientMatrix(){let t=[],s=this.equations,i=this.numberOfVariables,r=this.numberOfEquations;for(let e=0,n=s[e].coefficients;e<r;e++)for(let e=0;e<i;e++)t.push(n[e]);this.coefficientMatrix=new e(r,i,t)}computeConstantMatrix(){let t=[],s=this.equations,i=this.numberOfEquations;for(let e=0;e<i;e++)t.push(s[e].constant);this.constantMatrix=new e(i,1,t)}computeAugmentedMatrix(){let t=[],i=[],r=this.equations,n=this.numberOfEquations,l=this.numberOfVariables;for(let e=0;e<n;e++){let s=r[e],n=s.coefficients;for(let e=0;e<l;e++)t.push(n[e]);i.push(s.constant)}this.augmentedMatrix=new s(new e(n,l,t),new e(n,1,i))}lazyComputeAugmentedMatrix(){this.augmentedMatrix=new s(this.coefficientMatrix,this.constantMatrix)}forEach(t,e){let s=t.bind(e);this.equations.forEach(((t,e)=>{let i=t.coefficients,r=t.constant;s(t,i,r,e,this)}),this)}},t.Vector=class{constructor(t){this.elements=t,this.size={rows:t.length,columns:1},this.numberOfEntries=t.length}clone(){return new this.constructor(this.elements.slice())}equals(t){let e=this.numberOfEntries;if(e!==t.numberOfEntries)return!1;let s=this.elements,i=t.elements;for(let t=0;t<e;t++)if(s[t]!==i[t])return!1;return!0}multiplyScalar(t){let e=this.elements;for(let s=0,i=this.numberOfEntries;s<i;s++)e[s]*=t;return this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.numberOfEntries;if(e!==t.numberOfEntries)return console.error("Incompatible vectors for addition"),this;let s=this.elements,i=t.elements;for(let t=0;t<e;t++)s[t]+=i[t];return this}subtract(t){let e=this.numberOfEntries;if(e!==t.numberOfEntries)return console.error("Incompatible vectors for substraction"),this;let s=this.elements,i=t.elements;for(let t=0;t<e;t++)s[t]-=i[t];return this}dot(t){if(this.numberOfEntries!==t.numberOfEntries)return void console.error("Incompatible vectors for dot product");let e=this.elements,s=t.elements;return e.reduce(((t,e,i)=>t+e*s[i]),0)}},t.Vector2=class{constructor(t=0,e=0){this.x=t,this.y=e,this.elements=[t,e],this.size={rows:2,columns:1},this.numberOfEntries=2}clone(){return new this.constructor(this.x,this.y)}equals(t){let e=this.elements,s=t.elements;return this.numberOfEntries===t.numberOfEntries&&e[0]===s[0]&&e[1]===s[1]}multiplyScalar(t){let e=this.elements;return e[0]*=t,this.x=e[0],e[1]*=t,this.y=e[1],this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.elements,s=t.elements;return e[0]+=s[0],this.x=e[0],e[1]+=s[1],this.y=e[1],this}subtract(t){let e=this.elements,s=t.elements;return e[0]-=s[0],this.x=e[0],e[1]-=s[1],this.y=e[1],this}dot(t){let e=this.elements,s=t.elements;return e[0]*s[0]+e[1]*s[1]}},t.Vector3=class{constructor(t=0,e=0,s=0){this.x=t,this.y=e,this.z=s,this.elements=[t,e,s],this.size={rows:3,columns:1},this.numberOfEntries=3}clone(){return new this.constructor(this.x,this.y,this.z)}equals(t){let e=this.elements,s=t.elements;return this.numberOfEntries===t.numberOfEntries&&e[0]===s[0]&&e[1]===s[1]&&e[2]===s[2]}multiplyScalar(t){let e=this.elements;return e[0]*=t,this.x=e[0],e[1]*=t,this.y=e[1],e[2]*=t,this.z=e[2],this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.elements,s=t.elements;return e[0]+=s[0],this.x=e[0],e[1]+=s[1],this.y=e[1],e[2]+=s[2],this.z=e[2],this}subtract(t){let e=this.elements,s=t.elements;return e[0]-=s[0],this.x=e[0],e[1]-=s[1],this.y=e[1],e[2]-=s[2],this.z=e[2],this}dot(t){let e=this.elements,s=t.elements;return e[0]*s[0]+e[1]*s[1]+e[2]*s[2]}cross(t){let e=this.elements,s=t.elements;return new this.constructor(e[1]*s[2]-e[2]*s[1],e[2]*s[0]-e[0]*s[2],e[0]*s[1]-e[1]*s[0])}},t.Vector4=class{constructor(t=0,e=0,s=0,i=0){this.x=t,this.y=e,this.z=s,this.w=i,this.elements=[t,e,s,i],this.size={rows:4,columns:1},this.numberOfEntries=4}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}equals(t){let e=this.elements,s=t.elements;return this.numberOfEntries===t.numberOfEntries&&e[0]===s[0]&&e[1]===s[1]&&e[2]===s[2]&&e[3]===s[3]}multiplyScalar(t){let e=this.elements;return e[0]*=t,this.x=e[0],e[1]*=t,this.y=e[1],e[2]*=t,this.z=e[2],e[3]*=t,this.w=e[3],this}negate(){return this.multiplyScalar(-1)}add(t){let e=this.elements,s=t.elements;return e[0]+=s[0],this.x=e[0],e[1]+=s[1],this.y=e[1],e[2]+=s[2],this.z=e[2],e[3]+=s[3],this.w=e[3],this}subtract(t){let e=this.elements,s=t.elements;return e[0]-=s[0],this.x=e[0],e[1]-=s[1],this.y=e[1],e[2]-=s[2],this.z=e[2],e[3]-=s[3],this.w=e[3],this}dot(t){let e=this.elements,s=t.elements;return e[0]*s[0]+e[1]*s[1]+e[2]*s[2]+e[3]*s[3]}},Object.defineProperty(t,"__esModule",{value:!0})}));
