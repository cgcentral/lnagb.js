class t{constructor(t,s){this.coefficients=t,this.constant=s,this.numberOfVariables=t.length}clone(){return new this.constructor(this.coefficients,this.constant)}multiplyScalar(t){let s=this.coefficients;for(let e=0,i=this.numberOfVariables;e<i;e++)s[e]*=t;return this.constant*=t,this}negate(){return this.multiplyScalar(-1)}add(t){let s=this.numberOfVariables;if(s!==t.numberOfVariables)return console.error("Incompatible equations for addition"),this;let e=this.coefficients,i=t.coefficients;for(let t=0;t<s;t++)e[t]+=i[t];return this.constant+=t.constant,this}subtract(t){let s=this.numberOfVariables;if(t.numberOfVariables!==s)return console.error("Incompatible equations for subtraction"),this;let e=this.coefficients,i=t.coefficients;for(let t=0;t<s;t++)e[t]-=i[t];return this.constant-=t.constant,this}toArray(){return[...this.coefficients,this.constant]}}class s{constructor(t,s,e){this.a=t,this.b=s,this.c=e,this.coefficients=[t,s],this.constant=e,this.numberOfVariables=2}clone(){return new this.constructor(this.a,this.b,this.c)}multiplyScalar(t){let s=this.coefficients;return this.a=s[0]*=t,this.b=s[1]*=t,this.c=this.constant*=t,this}negate(){return this.multiplyScalar(-1)}add(t){let s=this.coefficients,e=t.coefficients;return this.a=s[0]+=e[0],this.b=s[1]+=e[1],this.c=this.constant+=t.constant,this}subtract(t){let s=this.coefficients,e=t.coefficients;return this.a=s[0]-=e[0],this.b=s[1]-=e[1],this.c=this.constant-=t.constant,this}}class e{constructor(t,s,e,i){this.a=t,this.b=s,this.c=e,this.d=i,this.coefficients=[t,s,e],this.constant=i,this.numberOfVariables=3}clone(){return new this.constructor(this.a,this.b,this.c,this.d)}multiplyScalar(t){let s=this.coefficients;return this.a=s[0]*=t,this.b=s[1]*=t,this.c=s[2]*=t,this.d=this.constant*=t,this}negate(){return this.multiplyScalar(-1)}add(t){let s=this.coefficients,e=t.coefficients;return this.a=s[0]+=e[0],this.b=s[1]+=e[1],this.c=s[2]+=e[2],this.d=this.constant+=t.constant,this}subtract(t){let s=this.coefficients,e=t.coefficients;return this.a=s[0]-=e[0],this.b=s[1]-=e[1],this.c=s[2]-=e[2],this.d=this.constant-=t.constant,this}}class i{constructor(t,s,e){this.size={rows:t,columns:s},this.numberOfEntries=t*s,this.elements=e||new Array(this.numberOfEntries).fill(0)}get rows(){let t=[],s=this.elements,e=this.size,i=e.rows,n=e.columns,r=0;for(let e=0;e<i;e++,r++){let e=[];for(let t=0;t<n;t++,r++)e.push(s[r]);t.push(e),r--}return t}get columns(){let t=[],s=this.elements,e=this.size,i=e.rows+1,n=e.columns,r=n+1,o=-n;for(let e=1;e<r;e++){let e=[],r=n;for(let t=1;t<i;t++)e.push(s[r+o]),r+=n;t.push(e),o++}return t}get mainDiagonal(){let t=this.elements,s=this.size,e=s.rows,i=s.columns,n=[],r=(e<i?e:i)+1,o=-1;for(let s=1;s<r;s++)n.push(t[o+s]),o+=i;return n}clone(){let t=this.size,s=t.rows,e=t.columns;return new this.constructor(s,e,this.elements.slice())}equals(t){let s=this.size,e=s.rows,i=s.columns,n=t.size;if(e!==n.rows||i!==n.columns)return!1;let r=this.elements,o=t.elements,l=e*i;for(let t=0;t<l;t++)if(r[t]!==o[t])return!1;return!0}entry(t,s){let e=this.size;return this.elements[t*e.columns+s-e.columns-1]}row(t){let s=this.elements,e=this.size.columns,i=t*e,n=[];for(let t=i-e;t<i;t++)n.push(s[t]);return n}column(t){let s=this.elements,e=this.size,i=e.rows,n=e.columns,r=[],o=i+1,l=t-(n+1),h=n;for(let t=1;t<o;t++)r.push(s[h+l]),h+=n;return r}leadingCoefficient(t){let s=this.elements,e=this.size.columns,i=t*e;for(let t,n=i-e;n<i;n++)if(t=s[n],0!==t)return t}forEach(t,s){let e=this,i=this.elements,n=i.length,r=this.size.columns,o=t.bind(s),l=1,h=1;for(let t=0;t<n;t++){o(i[t],l,h,t,e),h++,h>r&&(h=1,l++)}}forEachRow(t,s){let e=this,i=this.elements,n=this.size,r=n.rows,o=n.columns,l=t.bind(s),h=0;for(let t=1,s=r+1;t<s;t++,h++){let s=[];for(let t=0;t<o;t++,h++)s.push(i[h]);h--,l(s,t,e)}}forEachColumn(t,s){let e=this,i=this.elements,n=this.size,r=n.rows+1,o=n.columns,l=o+1,h=t.bind(s),c=-o;for(let t=1;t<l;t++){let s=[],n=o;for(let t=1;t<r;t++)s.push(i[n+c]),n+=o;h(s,t,e),c++}}interchargeRows(t,s){let e=this.elements,i=this.size.columns,n=i+1,r=t*i+1-n,o=s*i+1-n;for(let t=1;t<n;t++)[e[r++],e[o++]]=[e[o],e[r]];return this}multiplyRowByScalar(t,s){let e=this.elements,i=this.size.columns,n=t*i;for(let t=n-i;t<n;t++)e[t]*=s;return this}addRowTimesScalarToRow(t,s,e=1){let i=this.elements,n=this.size.columns,r=s*n;for(let s=t*n-n,o=r-n;o<r;s++,o++)i[s]+=i[o]*e;return this}transpose(){let t=this.elements,s=this.size,e=s.rows,i=e*s.columns,n=i-1,r=new Array(i);r[0]=t[0],r[n]=t[n];for(let s=1;s<n;s++)r[s*e%n]=t[s];return this.elements=r,[s.rows,s.columns]=[s.columns,s.rows],this}multiplyScalar(t){let s=this.elements;for(let e=0,i=this.numberOfEntries;e<i;e++)s[e]*=t;return this}negate(){return this.multiplyScalar(-1)}add(t){let s=this.size,e=t.size;if(s.rows!==e.rows||s.columns!==e.columns)return console.error("Incompatible matrices for addition"),this;let i=this.elements,n=t.elements,r=this.numberOfEntries;for(let t=0;t<r;t++)i[t]+=n[t];return this}sub(t){let s=this.size,e=t.size;if(s.rows!==e.rows||s.columns!==e.columns)return console.error("Incompatible matrices for subtraction"),this;let i=this.elements,n=t.elements,r=this.numberOfEntries;for(let t=0;t<r;t++)i[t]-=n[t];return this}multiply(t){let s=this.size,e=s.rows,i=s.columns,n=t.size,r=n.rows,o=n.columns;if(i!==r)return console.error("Input matrix is incompatible for multiplication"),this;let l=this.elements,h=t.elements,c=[],u=e+1,a=i+1,f=o+1;for(let t=1;t<u;t++)for(let s=1;s<f;s++){let e=0;for(let n=1;n<a;n++)e+=l[t*i+n-a]*h[n*o+s-f];c.push(e)}return this.elements=c,this.size.columns=o,this.numberOfEntries=e*o,this}}class n extends i{constructor(t,s){let e=t.size,i=s.size,n=e.rows,r=e.columns,o=i.columns,l=[];for(let e=1,i=n+1;e<i;e++)l.push(...t.row(e),...s.row(e));super(n,r+o,l),this.size.left=r,this.size.right=o}get leftMatrix(){let t=this.size,s=t.rows,e=t.left,n=[];for(let t=1;t<=s;t++)for(let s=1;s<=e;s++)n.push(this.entry(t,s));return new i(s,e,n)}get rightMatrix(){let t=this.size,s=t.rows,e=t.left,n=t.right,r=[];for(let t=1;t<=s;t++)for(let s=1;s<=n;s++)r.push(this.entry(t,e+s));return new i(s,n,r)}}n.prototype.transpose=void 0,n.prototype.add=void 0,n.prototype.sub=void 0,n.prototype.multiply=void 0;class r{constructor(t){this.equations=t,this.numberOfVariables=t[0].numberOfVariables,this.numberOfEquations=t.legnth}clone(){return new this.constructor(this.equations.slice())}computeCoefficientMatrix(){let t=[],s=this.equations,e=this.numberOfVariables,n=this.numberOfEquations;for(let i=0,r=s[i].coefficients;i<n;i++)for(let s=0;s<e;s++)t.push(r[s]);this.coefficientMatrix=new i(n,e,t)}computeConstantMatrix(){let t=[],s=this.equations,e=this.numberOfEquations;for(let i=0;i<e;i++)t.push(s[i].constant);this.constantMatrix=new i(e,1,t)}computeAugmentedMatrix(){let t=[],s=[],e=this.equations,r=this.numberOfEquations,o=this.numberOfVariables;for(let i=0;i<r;i++){let n=e[i],r=n.coefficients;for(let s=0;s<o;s++)t.push(r[s]);s.push(n.constant)}this.augmentedMatrix=new n(new i(r,o,t),new i(r,1,s))}lazyComputeAugmentedMatrix(){this.augmentedMatrix=new n(this.coefficientMatrix,this.constantMatrix)}forEach(t,s){let e=t.bind(s);this.equations.forEach(((t,s)=>{let i=t.coefficients,n=t.constant;e(t,i,n,s,this)}),this)}}export{t as LinearEquation,s as LinearEquation2,e as LinearEquation3,r as SystemOfLinearEquations};
